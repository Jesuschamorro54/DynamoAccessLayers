# ddb_client - Cliente DynamoDB

Documentaci√≥n completa del m√≥dulo `ddb_client` para operaciones con AWS DynamoDB.

## üìã Tabla de Contenidos

- [Introducci√≥n](#introducci√≥n)
- [Arquitectura](#arquitectura)
- [Configuraci√≥n](#configuraci√≥n)
- [M√≥dulo Searches](#m√≥dulo-searches)
- [M√≥dulo Updates](#m√≥dulo-updates)
- [Helpers](#helpers)
- [Mejores Pr√°cticas](#mejores-pr√°cticas)
- [Soluci√≥n de Problemas](#soluci√≥n-de-problemas)

## üéØ Introducci√≥n

El m√≥dulo `ddb_client` proporciona una interfaz de alto nivel para interactuar con AWS DynamoDB, abstrayendo la complejidad del SDK de boto3 y proporcionando funcionalidades adicionales como:

- ‚úÖ Validaci√≥n autom√°tica de esquemas
- ‚úÖ Manejo de palabras reservadas de DynamoDB
- ‚úÖ Operaciones batch optimizadas
- ‚úÖ Paginaci√≥n autom√°tica
- ‚úÖ Helpers de comparaci√≥n avanzados
- ‚úÖ Logging estructurado

### Ventajas sobre boto3 directo

| Caracter√≠stica | boto3 | ddb_client |
|----------------|-------|------------|
| Validaci√≥n de esquema | ‚ùå | ‚úÖ |
| Manejo de palabras reservadas | Manual | Autom√°tico |
| Operaciones batch | Manual | Simplificado |
| Paginaci√≥n | Manual | Autom√°tico |
| Helpers de comparaci√≥n | ‚ùå | ‚úÖ |
| Type hints | Parcial | Completo |

## üèóÔ∏è Arquitectura

```
ddb_client/
‚îú‚îÄ‚îÄ __init__.py         # Exports principales
‚îú‚îÄ‚îÄ config.py           # Configuraci√≥n global
‚îú‚îÄ‚îÄ constants.py        # Constantes (palabras reservadas)
‚îú‚îÄ‚îÄ searches.py         # Operaciones de lectura
‚îú‚îÄ‚îÄ updates.py          # Operaciones de escritura
‚îú‚îÄ‚îÄ helpers.py          # Helpers de comparaci√≥n
‚îî‚îÄ‚îÄ utils.py            # Utilidades internas
```

### Flujo de operaciones

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Usuario/Lambda ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ddb_client API ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚ñ∫ config.py (validaci√≥n)
         ‚îú‚îÄ‚ñ∫ utils.py (schema, conversi√≥n)
         ‚îî‚îÄ‚ñ∫ boto3 (DynamoDB)
```

## ‚öôÔ∏è Configuraci√≥n

### config.py

Archivo de configuraci√≥n central para el m√≥dulo:

```python
# config.py

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CONFIGURACI√ìN DE PAGINACI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Habilitar/deshabilitar paginaci√≥n global
paginate = True

# N√∫mero de registros por p√°gina
pages = 50

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CAMPOS POR DEFECTO PARA B√öSQUEDAS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

fields = {
    # Tabla de certificaciones
    'bas_certifications': [
        'id',
        'user_id',
        'curso_id',
        'estado',
        'score',
        'created_at',
        'updated_at'
    ],
    
    # Tabla de usuarios
    'bas_users': [
        'user_id',
        'user_name',
        'email',
        'created_at',
        'last_login'
    ],
    
    # Tabla sin campos espec√≠ficos (retorna todos)
    'bas_portfolio': []
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CAMPOS PERMITIDOS PARA ACTUALIZACIONES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

allowed_fields = {
    'bas_certifications': [
        'estado',
        'score',
        'completed_at',
        'progress',
        'notes',
        'metadata',
        'metadata.course_data',
        'metadata.user_data'  # Soporte para campos anidados
    ],
    
    'bas_users': [
        'user_name',
        'email',
        'cellphone',
        'image',
        'last_login',
        'preferences',
        'preferences.language',
        'preferences.notifications'
    ]
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# VALORES POR DEFECTO AL CREAR REGISTROS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

defaults = {
    'data': {
        'bas_certifications': {
            'estado': 0,           # Estado inicial: inactivo
            'score': 0,            # Score inicial: 0
            'progress': 0,         # Progreso inicial: 0%
            'attempts': 0          # Intentos: 0
        },
        
        'bas_users': {
            'role': 'student',
            'active': 1,
            'verified': 0
        },
        
        # Tabla sin defaults
        'bas_portfolio': {}
    }
}
```

### Palabras Reservadas

El m√≥dulo maneja autom√°ticamente las palabras reservadas de DynamoDB. Si usas una palabra reservada como nombre de campo, se maneja internamente:

```python
# ‚ùå boto3 directo - ERROR
table.query(KeyConditionExpression=Key('user_id').eq('123') & Key('status').eq(1))

# ‚úÖ ddb_client - Funciona autom√°ticamente
dynamo_search('table', {'user_id': '123', 'status': 1})
```

La lista completa de palabras reservadas est√° en `constants.py` (108 palabras).

## üîç M√≥dulo Searches

Operaciones de lectura y consulta en DynamoDB.

### Imports

```python
from ddb_client.searches import (
    dynamo_search,      # B√∫squeda principal con filtros
    dynamo_counter,     # Contador de registros
    batch_get_items     # Obtener m√∫ltiples items
)
```

---

### dynamo_search

Funci√≥n principal para realizar b√∫squedas en DynamoDB.

#### Firma

```python
def dynamo_search(
    table: str,
    params: dict,
    limit: bool = False,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla DynamoDB | ‚úÖ |
| `params` | dict | Par√°metros de b√∫squeda (keys + filtros) | ‚úÖ |
| `limit` | bool | Habilitar paginaci√≥n | ‚ùå |
| `index` | str | Nombre del √≠ndice GSI/LSI | ‚ùå |
| `order` | str | Orden: 'ASC' o 'DESC' | ‚ùå |
| `order_by` | str | LSI para ordenar | ‚ùå |
| `pages` | int | Registros por p√°gina | ‚ùå |
| `log_errors` | bool | Mostrar errores (default: True) | ‚ùå |
| `log_qparams` | bool | Mostrar query construido | ‚ùå |
| `log_schema` | bool | Mostrar esquema de tabla | ‚ùå |

#### Retorno

```python
{
    "Items": [...],                # Lista de items encontrados
    "Count_Items": 10,             # Cantidad de items
    "LastEvaluatedKey": {...}      # Clave para siguiente p√°gina (opcional)
}
```

#### Ejemplos

**B√∫squeda simple por PK**

```python
params = {
    'user_id': '425034'
}

result = dynamo_search('bas_certifications', params)
# Retorna todos los registros del usuario
```

**B√∫squeda por PK y SK**

```python
params = {
    'user_id': '425034',
    'curso_id': '1234'
}

result = dynamo_search('bas_certifications', params)
# Retorna el registro espec√≠fico
```

**B√∫squeda con campos espec√≠ficos**

```python
params = {
    'user_id': '425034',
    'fields': ['id', 'curso_id', 'estado', 'score']
}

result = dynamo_search('bas_certifications', params, limit=True)
# Solo retorna los campos especificados
```

**B√∫squeda con filtros**

```python
from ddb_client.helpers import DynamoComparison as dc

params = {
    'user_id': '425034',
    'estado': dc.Ne(-1),              # Estado diferente de -1
    'score': dc.Ge(80),               # Score >= 80
    'created_at': dc.BeginsWith('2024')  # Creados en 2024
}

result = dynamo_search('bas_certifications', params)
```

**B√∫squeda con √≠ndice GSI**

```python
params = {
    'curso_id': '1234',     # PK del √≠ndice
    'estado': 1             # FK del √≠ndice
}

result = dynamo_search(
    'bas_certifications',
    params,
    index='curso_estado-index'
)
```

**B√∫squeda con ordenamiento**

```python
params = {
    'user_id': '425034'
}

# Orden descendente
result = dynamo_search(
    'bas_certifications',
    params,
    order='DESC',
    limit=True,
    pages=10
)

# Ordenar por LSI
result = dynamo_search(
    'bas_certifications',
    params,
    order_by='user_date-index'  # LSI name
)
```

**Paginaci√≥n**

```python
# Primera p√°gina
params = {'user_id': '425034'}
result = dynamo_search('bas_certifications', params, limit=True, pages=20)

# Siguiente p√°gina
if 'LastEvaluatedKey' in result:
    params['LastEvaluatedKey'] = result['LastEvaluatedKey']
    next_page = dynamo_search('bas_certifications', params, limit=True, pages=20)
```

**Debug con logs**

```python
result = dynamo_search(
    'bas_certifications',
    {'user_id': '425034', 'estado': dc.Ge(0)},
    log_qparams=True,   # Ver query construido
    log_schema=True,    # Ver esquema de tabla
    log_errors=True     # Ver errores detallados
)
```

---

### dynamo_counter

Cuenta el n√∫mero total de registros que cumplen una condici√≥n.

#### Firma

```python
def dynamo_counter(
    table: str,
    params: dict,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `params` | dict | Par√°metros de b√∫squeda | ‚úÖ |
| `log_qparams` | bool | Mostrar query | ‚ùå |
| `log_schema` | bool | Mostrar esquema | ‚ùå |
| `log_errors` | bool | Mostrar errores | ‚ùå |

#### Retorno

```python
{
    "Count_Items": 150,    # Total de items
    "Pages": 3             # N√∫mero de p√°ginas (seg√∫n config.pages)
}
```

#### Ejemplos

```python
# Contar todos los registros de un usuario
params = {'user_id': '425034'}
result = dynamo_counter('bas_certifications', params)
print(f"Total: {result['Count_Items']}, P√°ginas: {result['Pages']}")

# Contar con filtros
from ddb_client.helpers import DynamoComparison as dc

params = {
    'user_id': '425034',
    'estado': dc.Eq(1),  # Solo activos
    'score': dc.Ge(70)   # Score >= 70
}

result = dynamo_counter('bas_certifications', params)
```

---

### batch_get_items

Obtiene m√∫ltiples items en una sola operaci√≥n usando sus claves primarias.

#### Firma

```python
def batch_get_items(
    table: str,
    source: list,
    **args
) -> list
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `source` | list | Lista de items con las claves | ‚úÖ |
| `{pk_name}` | str | Mapeo de PK (key=valor) | ‚úÖ |
| `{sk_name}` | str | Mapeo de SK (key=valor) | ‚ùå |
| `fields` | list | Campos a retornar | ‚ùå |
| `log_keys` | bool | Log de claves procesadas | ‚ùå |
| `log_result` | bool | Log del resultado | ‚ùå |

#### Retorno

```python
[
    {...},  # Item 1
    {...},  # Item 2
    {...}   # Item N
]
```

#### Ejemplos

**Solo Primary Key**

```python
# Lista de IDs a buscar
source = [
    {'id': 'abc123'},
    {'id': 'def456'},
    {'id': 'ghi789'}
]

# Especificar mapeo: tabla usa 'user_id', source usa 'id'
items = batch_get_items('bas_users', source, user_id='id')
```

**Primary Key + Sort Key**

```python
# Lista con PK y SK
attempts = [
    {'user': '425034', 'course': '4350'},
    {'user': '425034', 'course': '4467'},
    {'user': '568745', 'course': '4350'}
]

# Especificar ambos mapeos
items = batch_get_items(
    'bas_certifications',
    attempts,
    user_id='user',      # PK mapping
    curso_id='course'    # SK mapping
)
```

**Con campos espec√≠ficos**

```python
attempts = [
    {'user': '425034', 'course': '4350'},
    {'user': '425034', 'course': '4467'}
]

items = batch_get_items(
    'bas_certifications',
    attempts,
    user_id='user',
    curso_id='course',
    fields=['user_id', 'curso_id', 'estado', 'score']
)
```

**Con valores anidados**

```python
# Source con datos anidados
source = [
    {
        'metadata': {
            'user_data': {
                'id': '425034'
            }
        },
        'course_info': {
            'id': '1234'
        }
    }
]

# Usar dot notation para acceder
items = batch_get_items(
    'bas_certifications',
    source,
    user_id='metadata.user_data.id',
    curso_id='course_info.id'
)
```

**Con logging para debug**

```python
items = batch_get_items(
    'bas_certifications',
    attempts,
    user_id='user_id',
    curso_id='curso_id',
    log_keys=True,      # Ver claves procesadas
    log_result=True     # Ver respuesta DynamoDB
)
```

#### L√≠mites

- M√°ximo **100 items** por batch (l√≠mite de DynamoDB)
- Autom√°ticamente divide en m√∫ltiples batches si es necesario
- Maneja `UnprocessedKeys` autom√°ticamente con reintentos

---

## üìù M√≥dulo Updates

Operaciones de escritura en DynamoDB.

### Imports

```python
from ddb_client.updates import (
    dynamo_create,       # Crear registro
    batch_create_items,  # Crear m√∫ltiples registros
    dynamo_update,       # Actualizar registro
    batch_update_items,  # Actualizar m√∫ltiples registros
    dynamo_increase,     # Incrementar campos
    dynamo_delete,       # Eliminar registro
    batch_delete_items   # Eliminar m√∫ltiples registros
)
```

---

### dynamo_create

Crea un nuevo registro en DynamoDB.

#### Firma

```python
def dynamo_create(
    table: str,
    data: dict,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `data` | dict | Datos del registro | ‚úÖ |
| `log_qparams` | bool | Log del item | ‚ùå |
| `log_errors` | bool | Log de errores | ‚ùå |

#### Retorno

```python
{
    "data": {...},        # Item creado completo
    "status": True        # True si fue exitoso
}
```

#### Campos Autom√°ticos

La funci√≥n agrega autom√°ticamente (si no existen en `data`):

```python
{
    'id': 'uuid4-generado',
    'timestamp': 1234567890123,  # Unix timestamp en ms
    'created_at': '2024-01-15T10:30:00.000Z'  # ISO 8601 UTC
}
```

#### Ejemplos

**Creaci√≥n b√°sica**

```python
data = {
    'user_id': '425034',
    'curso_id': '1234',
    'name': 'Curso de Python'
}

result = dynamo_create('bas_certifications', data)

if result['status']:
    print(f"Creado con ID: {result['data']['id']}")
```

**Con valores por defecto**

Los valores en `config.defaults` se aplican autom√°ticamente:

```python
# config.py tiene:
# defaults['data']['bas_certifications'] = {'estado': 0, 'score': 0}

data = {
    'user_id': '425034',
    'curso_id': '1234'
}

result = dynamo_create('bas_certifications', data)
# result['data'] incluir√°: estado=0, score=0
```

**Sobrescribir campos autom√°ticos**

```python
data = {
    'id': 'custom-id-123',           # Usar ID personalizado
    'user_id': '425034',
    'curso_id': '1234',
    'created_at': '2024-01-01T00:00:00Z'  # Fecha personalizada
}

result = dynamo_create('bas_certifications', data)
# Respeta los valores proporcionados
```

---

### batch_create_items

Crea m√∫ltiples registros en una sola operaci√≥n.

#### Firma

```python
def batch_create_items(
    table: str,
    source: list,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `source` | list | Lista de items a crear | ‚úÖ |
| `{pk_name}` | str | Mapeo de PK | ‚úÖ |
| `{sk_name}` | str | Mapeo de SK | ‚ùå |
| `log_keys` | bool | Log de items | ‚ùå |
| `log_result` | bool | Log de respuesta | ‚ùå |

#### Retorno

```python
{
    "status": True,      # True si alguno fue exitoso
    "row_count": 25      # N√∫mero de registros creados
}
```

#### Ejemplos

```python
items = [
    {'user': '123', 'course': '456', 'name': 'Item 1'},
    {'user': '123', 'course': '789', 'name': 'Item 2'},
    {'user': '456', 'course': '456', 'name': 'Item 3'}
]

result = batch_create_items(
    'bas_certifications',
    items,
    user_id='user',
    curso_id='course'
)

print(f"Creados: {result['row_count']} registros")
```

#### L√≠mites

- M√°ximo **25 items** por batch (l√≠mite DynamoDB)
- Autom√°ticamente divide en m√∫ltiples batches
- Maneja `UnprocessedItems` con reintentos

---

### dynamo_update

Actualiza un registro existente.

#### Firma

```python
def dynamo_update(
    table: str,
    keys: dict,
    data: dict,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `keys` | dict | Claves del registro (PK + SK) | ‚úÖ |
| `data` | dict | Campos a actualizar | ‚úÖ |
| `{field}` | any | Condiciones (kwargs) | ‚ùå |
| `log_qparams` | bool | Log de query | ‚ùå |
| `log_schema` | bool | Log de esquema | ‚ùå |
| `log_keys` | bool | Log de claves | ‚ùå |
| `log_criticals` | bool | Log de campos filtrados | ‚ùå |

#### Retorno

```python
{
    "status": True,      # True si fue exitoso
    "row_count": 1       # 1 si se actualiz√≥, 0 si no
}
```

#### Ejemplos

**Actualizaci√≥n simple**

```python
keys = {
    'user_id': '425034',
    'curso_id': '1234'
}

data = {
    'estado': 1,
    'score': 95,
    'completed_at': '2024-01-15T10:00:00Z'
}

result = dynamo_update('bas_certifications', keys, data)
```

**Con actualizaci√≥n condicional**

```python
keys = {
    'user_id': '425034',
    'curso_id': '1234'
}

data = {
    'score': 100
}

# Solo actualizar si estado = 1
result = dynamo_update(
    'bas_certifications',
    keys,
    data,
    estado=1  # Condici√≥n
)
```

**Actualizar campos anidados**

```python
# config.py debe incluir el campo anidado en allowed_fields
# allowed_fields['table'] = ['metadata.progress', 'metadata.last_lesson']

data = {
    'metadata': {'progress': 75, 'last_lesson': 10}
}

result = dynamo_update('bas_certifications', keys, data)
```

**Protecci√≥n de campos no permitidos**

```python
# Si un campo NO est√° en config.allowed_fields, se filtra:

data = {
    'score': 95,              # ‚úÖ Permitido
    'user_id': 'other-user',  # ‚ùå Filtrado (no permitido)
    'secret_field': 'xxx'     # ‚ùå Filtrado
}

result = dynamo_update('bas_certifications', keys, data, log_criticals=True)
# Log: "Filtered fields not allowed: ['user_id', 'secret_field']"
```

**Eliminar campos con None**

```python
# Pasar None como valor elimina el campo del registro
keys = {
    'user_id': '425034',
    'curso_id': '1234'
}

data = {
    'score': 95,
    'temp_token': None,      # ‚úÖ Este campo se eliminar√°
    'session_id': None       # ‚úÖ Este campo se eliminar√°
}

result = dynamo_update('bas_certifications', keys, data)
# El item ya no tendr√° temp_token ni session_id
```

---

### batch_update_items

> ‚ö†Ô∏è **Nota de eficiencia:**  
> La funci√≥n `batch_update_items` **no es eficiente para grandes vol√∫menes** porque realiza un ciclo de:
>
> 1. **Batch Get:** Lee todos los registros completos antes de actualizar (requiere un batch read por cada grupo de hasta 100 items).
> 2. **Merge en memoria:** Realiza el merge en Python, lo cual puede ser lento con muchos items o registros grandes.
> 3. **Batch Write:** Escribe cada registro actualizado completo, incluso si solo cambian algunos campos.
>
> DynamoDB **no tiene batch update nativo**; por eso esta t√©cnica hace sobrescritura total (`PutRequest`) de cada registro actualizado.  
> - Si tienes miles de items para actualizar, usa estrategias paginadas o eval√∫a solicitudes puntuales de `update_item` para minimizar lecturas y escrituras.
> - Para casos de actualizaci√≥n masiva de pocos campos y muchos registros, es mejor un proceso dedicado fuera de Lambda o scripts controlados.
>


Actualiza m√∫ltiples registros en una sola operaci√≥n, combinando `batch_get` y `batch_write` para preservar campos no especificados.

#### Firma

```python
def batch_update_items(
    table: str,
    source: list,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `source` | list | Lista de items con keys + datos a actualizar | ‚úÖ |
| `log_keys` | bool | Log de claves procesadas | ‚ùå |
| `log_result` | bool | Log de respuestas DynamoDB | ‚ùå |
| `log_merge` | bool | Log del merge de datos | ‚ùå |
| `return_items` | bool | Retornar items actualizados | ‚ùå |

#### Retorno

```python
{
    "status": True,       # True si fue exitoso
    "row_count": 10,      # N√∫mero de registros actualizados
    "items": [...]        # Items actualizados (si return_items=True)
}
```

#### C√≥mo Funciona

Esta funci√≥n implementa una estrategia de "merge inteligente" en 4 pasos:

1. **Extracci√≥n de Keys**: Detecta autom√°ticamente PK y SK del schema, extrae las keys de cada item
2. **Batch Get**: Obtiene los registros completos existentes (ignora `config.fields`, trae TODOS los campos)
3. **Merge**: Combina datos existentes con actualizaciones, preservando campos no especificados
4. **Batch Write**: Sobrescribe items completos usando `batch_write_item`

**Caracter√≠sticas especiales:**
- ‚úÖ **No requiere especificar mapeos** como otras funciones batch (detecta PK/SK autom√°ticamente)
- ‚úÖ **Preserva campos no especificados** (solo actualiza los campos que env√≠as)
- ‚úÖ **Soporta eliminaci√≥n con None** (campos con valor `None` se eliminan)
- ‚úÖ **Valida items duplicados** y advierte sobre items no encontrados

#### Ejemplos

**Actualizaci√≥n b√°sica**

```python
updates = [
    {
        'user_id': '425034',      # PK (detectada autom√°ticamente)
        'curso_id': '1234',       # SK (detectada autom√°ticamente)
        'last_online': '2025-01-15 10:30:00',
        'score': 95
    },
    {
        'user_id': '425034',
        'curso_id': '5678',
        'last_online': '2025-01-15 11:00:00',
        'progress': 75
    }
]

result = batch_update_items('bas_certifications', updates)
print(f"Actualizados: {result['row_count']} registros")
```

**Con eliminaci√≥n de campos**

```python
# Eliminar campos temporales de m√∫ltiples usuarios
updates = [
    {
        'user_id': '425034',
        'curso_id': '1234',
        'temp_token': None,       # Se eliminar√°
        'session_id': None,       # Se eliminar√°
        'last_login': '2025-01-15'
    },
    {
        'user_id': '568745',
        'curso_id': '1234',
        'temp_field': None,       # Se eliminar√°
        'score': 100
    }
]

result = batch_update_items('bas_certifications', updates)
```

**Con logs para debugging**

```python
result = batch_update_items(
    'bas_certifications',
    updates,
    log_keys=True,      # Ver keys extra√≠das
    log_result=True,    # Ver respuestas DynamoDB
    log_merge=True      # Ver merge de cada item
)

# Output logs:
# INFO: Keys to fetch: [{'user_id': '425034', 'curso_id': '1234'}, ...]
# INFO: Fetched 2 existing items
# INFO: Merged item for key (425034, 1234) -> Result: {...}
# INFO: Successfully updated 2 items in table 'bas_certifications'
```

**Retornar items actualizados**

```python
result = batch_update_items(
    'bas_certifications',
    updates,
    return_items=True  # Incluir items en la respuesta
)

if result['status']:
    for item in result['items']:
        print(f"Updated: {item['user_id']} - {item['curso_id']}")
```

**Actualizaci√≥n masiva desde API externa**

```python
# Sincronizar datos desde sistema externo
external_data = [
    {'user_id': '123', 'curso_id': '456', 'external_score': 95},
    {'user_id': '123', 'curso_id': '789', 'external_score': 88},
    # ... m√°s registros
]

# Actualizar preservando campos locales
result = batch_update_items('bas_certifications', external_data)
# Los campos como 'created_at', 'attempts', etc. se preservan
```

#### Comparaci√≥n con Alternativas

| Caracter√≠stica | `batch_update_items` | Loop con `dynamo_update` | `batch_write_item` directo |
|----------------|---------------------|-------------------------|---------------------------|
| **Preserva campos no especificados** | ‚úÖ Autom√°tico | ‚úÖ Con UpdateExpression | ‚ùå Sobrescribe todo |
| **Operaciones por llamada** | 2 (get + write) | N (una por item) | 1 (solo write) |
| **Detecta PK/SK autom√°tico** | ‚úÖ S√≠ | ‚ö†Ô∏è Manual | ‚ö†Ô∏è Manual |
| **Elimina campos con None** | ‚úÖ S√≠ | ‚úÖ S√≠ (REMOVE) | ‚ùå No |
| **L√≠mite de items** | 100 get + 25 write | Ilimitado | 25 |
| **Performance** | ‚ö†Ô∏è 2 operaciones | ‚ùå N operaciones | ‚úÖ 1 operaci√≥n |
| **Costo RCU/WCU** | Alto (lee todo) | Bajo (solo update) | Medio |

#### Casos de Uso Ideales

**‚úÖ Cuando usar `batch_update_items`:**
- Actualizar m√∫ltiples registros con campos parciales
- Sincronizar datos desde fuentes externas
- Limpiar campos temporales de m√∫ltiples registros
- Necesitas preservar campos existentes no especificados

**‚ùå Cuando NO usar `batch_update_items`:**
- Crear nuevos registros (usa `batch_create_items`)
- Actualizar UN solo registro (usa `dynamo_update`)
- Actualizar campos muy espec√≠ficos sin leer el resto (usa `dynamo_update`)
- Necesitas actualizaciones condicionales (usa `dynamo_update`)

#### L√≠mites y Consideraciones

- **L√≠mite Batch Get**: M√°ximo 100 items por batch (autom√°ticamente dividido)
- **L√≠mite Batch Write**: M√°ximo 25 items por batch (autom√°ticamente dividido)
- **Items no encontrados**: Advierte en logs, no crea registros nuevos
- **Costo**: Consume RCU para leer + WCU para escribir (m√°s costoso que `UpdateItem`)
- **No condicional**: No soporta `ConditionExpression`, sobrescribe sin validaciones
- **Manejo autom√°tico**: Procesa `UnprocessedKeys` y `UnprocessedItems` autom√°ticamente

#### Ejemplo Completo de Flujo

```python
# Estado inicial en DynamoDB
# {
#   'user_id': '425034',
#   'curso_id': '1234',
#   'name': 'John Doe',
#   'email': 'john@test.com',
#   'score': 80,
#   'attempts': 3,
#   'created_at': '2024-01-01T00:00:00Z'
# }

# Actualizaci√≥n enviada
updates = [
    {
        'user_id': '425034',
        'curso_id': '1234',
        'score': 95,                # Actualizar
        'last_online': '2025-01-15' # Agregar nuevo campo
    }
]

result = batch_update_items('bas_certifications', updates)

# Estado final en DynamoDB (merge autom√°tico)
# {
#   'user_id': '425034',
#   'curso_id': '1234',
#   'name': 'John Doe',           # ‚úÖ Preservado
#   'email': 'john@test.com',     # ‚úÖ Preservado
#   'score': 95,                  # ‚úÖ Actualizado
#   'attempts': 3,                # ‚úÖ Preservado
#   'created_at': '2024-01-01T00:00:00Z', # ‚úÖ Preservado
#   'last_online': '2025-01-15'   # ‚úÖ Nuevo campo agregado
# }
```

---

### dynamo_increase

Incrementa o decrementa campos num√©ricos de forma at√≥mica.

#### Firma

```python
def dynamo_increase(
    table: str,
    params: dict,
    data: dict,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `params` | dict | Claves del registro + l√≠mites | ‚úÖ |
| `data` | dict | Campos a incrementar | ‚úÖ |
| `log_qparams` | bool | Log de query | ‚ùå |
| `log_schema` | bool | Log de esquema | ‚ùå |
| `log_errors` | bool | Log de errores | ‚ùå |

#### Retorno

```python
{
    "status": True,      # True si fue exitoso
    "row_count": 1       # 1 si se actualiz√≥
}
```

#### Ejemplos

**Incremento simple**

```python
params = {
    'user_id': '425034',
    'curso_id': '1234'
}

data = {
    'score': 5,      # Incrementar 5 puntos
    'attempts': 1    # Incrementar 1 intento
}

result = dynamo_increase('bas_certifications', params, data)
```

**Decremento**

```python
data = {
    'lives': -1,      # Decrementar 1 vida
    'credits': -10    # Decrementar 10 cr√©ditos
}

result = dynamo_increase('bas_game_state', params, data)
```

**Con l√≠mite m√°ximo**

```python
params = {
    'user_id': '425034',
    'curso_id': '1234',
    'score_max': 100  # No permitir score > 100
}

data = {
    'score': 10  # Intentar incrementar 10
}

result = dynamo_increase('bas_certifications', params, data)
# Si score actual es 95, solo se incrementar√° a 100
```

**Con l√≠mite m√≠nimo**

```python
params = {
    'user_id': '425034',
    'curso_id': '1234',
    'lives_min': 0  # No permitir vidas negativas
}

data = {
    'lives': -2  # Intentar decrementar 2
}

result = dynamo_increase('bas_game_state', params, data)
# Si lives actual es 1, la operaci√≥n fallar√°
```

**M√∫ltiples campos con l√≠mites**

```python
params = {
    'user_id': '425034',
    'curso_id': '1234',
    'score_min': 0,
    'score_max': 100,
    'attempts_min': 0,
    'attempts_max': 10
}

data = {
    'score': 5,
    'attempts': 1
}

result = dynamo_increase('bas_certifications', params, data)
```

---

### dynamo_delete

Elimina un registro de DynamoDB.

#### Firma

```python
def dynamo_delete(
    table: str,
    params: dict,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `params` | dict | Claves del registro | ‚úÖ |
| `return_values` | bool | Retornar valores antes de eliminar | ‚ùå |
| `log_qparams` | bool | Log de query | ‚ùå |
| `log_schema` | bool | Log de esquema | ‚ùå |
| `log_errors` | bool | Log de errores | ‚ùå |

#### Retorno

```python
{
    "status": True,      # True si fue exitoso
    "row_count": 1       # 1 si se elimin√≥, 0 si no exist√≠a
}
```

#### Ejemplos

**Eliminaci√≥n simple**

```python
params = {
    'user_id': '425034',
    'curso_id': '1234'
}

result = dynamo_delete('bas_certifications', params)

if result['status']:
    print("Registro eliminado")
```

**Sin retornar valores**

```python
result = dynamo_delete(
    'bas_certifications',
    params,
    return_values=False
)
```

---

### batch_delete_items

Elimina m√∫ltiples registros en una sola operaci√≥n.

#### Firma

```python
def batch_delete_items(
    table: str,
    source: list,
    **args
) -> dict
```

#### Par√°metros

| Par√°metro | Tipo | Descripci√≥n | Requerido |
|-----------|------|-------------|-----------|
| `table` | str | Nombre de la tabla | ‚úÖ |
| `source` | list | Lista de claves a eliminar | ‚úÖ |
| `{pk_name}` | str | Mapeo de PK | ‚úÖ |
| `{sk_name}` | str | Mapeo de SK | ‚ùå |
| `log_keys` | bool | Log de claves | ‚ùå |
| `log_result` | bool | Log de respuesta | ‚ùå |

#### Retorno

```python
{
    "status": True,      # True si alguno fue eliminado
    "row_count": 15      # N√∫mero de registros eliminados
}
```

#### Ejemplos

```python
to_delete = [
    {'user_id': '123', 'curso_id': '456'},
    {'user_id': '123', 'curso_id': '789'},
    {'user_id': '456', 'curso_id': '123'}
]

result = batch_delete_items(
    'bas_certifications',
    to_delete,
    user_id='user_id',
    curso_id='curso_id'
)

print(f"Eliminados: {result['row_count']} registros")
```

---

## üõ†Ô∏è Helpers

### DynamoComparison

Clase para construir expresiones de comparaci√≥n avanzadas.

#### Imports

```python
from ddb_client.helpers import DynamoComparison as dc
```

#### Operadores de Comparaci√≥n

| M√©todo | Descripci√≥n | Ejemplo |
|--------|-------------|---------|
| `Eq(value)` | Igual a | `dc.Eq('active')` |
| `Ne(value)` | Diferente de | `dc.Ne(-1)` |
| `Lt(value)` | Menor que | `dc.Lt(100)` |
| `Le(value)` | Menor o igual | `dc.Le(100)` |
| `Gt(value)` | Mayor que | `dc.Gt(0)` |
| `Ge(value)` | Mayor o igual | `dc.Ge(70)` |
| `Between(start, end)` | Entre dos valores | `dc.Between(10, 100)` |
| `BeginsWith(value)` | Comienza con | `dc.BeginsWith('2024')` |
| `Contains(value)` | Contiene | `dc.Contains('python')` |
| `NotContains(value)` | No contiene | `dc.NotContains('test')` |
| `In(values)` | En lista | `dc.In(['a', 'b', 'c'])` |
| `Null()` | Es nulo | `dc.Null()` |
| `NotNull()` | No es nulo | `dc.NotNull()` |

#### Operadores L√≥gicos

**OR**

```python
params = {
    'user_id': '425034',
    'estado': dc.Or([
        dc.Eq('active'),
        dc.Eq('pending'),
        dc.Eq('processing')
    ])
}
```

**AND**

```python
params = {
    'user_id': '425034',
    'score': dc.And([
        dc.Ge(70),     # score >= 70
        dc.Le(100)     # score <= 100
    ])
}
```

**Combinaciones complejas**

```python
params = {
    'user_id': '425034',
    'estado': dc.Or([
        dc.Eq('active'),
        dc.Eq('pending')
    ]),
    'score': dc.And([
        dc.Ge(70),
        dc.Lt(100)
    ]),
    'created_at': dc.BeginsWith('2024')
}
```

#### Uso con Sort Keys

```python
# Sort Key con comparador
params = {
    'user_id': '425034',
    'curso_id': dc.BeginsWith('course_', is_key=True)
}

result = dynamo_search('bas_certifications', params)
```

---

## üêõ Soluci√≥n de Problemas

### Error: "Key not found in schema"

**Causa**: La clave especificada no existe en el esquema de la tabla.

**Soluci√≥n**:

```python
# ‚ùå Incorrecto
params = {'user_id': '123'}
dynamo_search('table_con_otro_pk', params)

# ‚úÖ Correcto - verificar esquema primero
result = dynamo_search('table', params, log_schema=True)
# Revisar los logs para ver el esquema real
```

### Error: "Field not allowed"

**Causa**: Intentas actualizar un campo no incluido en `config.allowed_fields`.

**Soluci√≥n**:

```python
# Agregar el campo a config.py
allowed_fields = {
    'tu_tabla': [
        'campo_existente',
        'campo_nuevo'  # ‚Üê Agregar aqu√≠
    ]
}
```

### Error: "ConditionalCheckFailedException"

**Causa**: En `dynamo_increase`, se alcanz√≥ un l√≠mite min/max.

**Soluci√≥n**:

```python
# Verificar l√≠mites
params = {
    'user_id': '123',
    'score_max': 100
}
data = {'score': 10}

try:
    result = dynamo_increase('table', params, data)
except Exception as e:
    if 'ConditionalCheckFailedException' in str(e):
        print("L√≠mite alcanzado")
```

### Paginaci√≥n infinita

**Causa**: No se maneja correctamente `LastEvaluatedKey`.

**Soluci√≥n**:

```python
# ‚úÖ Siempre verificar antes del siguiente loop
while True:
    result = dynamo_search(table, params, limit=True)
    
    # Procesar items...
    
    # ‚úÖ Verificar si hay m√°s p√°ginas
    if 'LastEvaluatedKey' not in result:
        break  # ‚Üê IMPORTANTE
    
    params['LastEvaluatedKey'] = result['LastEvaluatedKey']
```

### Performance lento en b√∫squedas

**Causas y soluciones**:

1. **Filtros en campos no indexados**
   ```python
   # ‚ùå Lento - filtra despu√©s de obtener todos
   params = {'user_id': '123', 'some_field': 'value'}
   
   # ‚úÖ R√°pido - usar √≠ndice GSI
   params = {'indexed_field': 'value'}
   dynamo_search(table, params, index='gsi_name')
   ```

2. **Retornando demasiados campos**
   ```python
   # ‚ùå Lento - retorna todo
   result = dynamo_search(table, params)
   
   # ‚úÖ R√°pido - solo campos necesarios
   params = {'user_id': '123', 'fields': ['id', 'name']}
   result = dynamo_search(table, params)
   ```

3. **Sin l√≠mite de paginaci√≥n**
   ```python
   # ‚ùå Lento - obtiene todo de una vez
   result = dynamo_search(table, params, limit=False)
   
   # ‚úÖ R√°pido - paginar resultados
   result = dynamo_search(table, params, limit=True, pages=50)
   ```

---

## üìö Referencias

- [DynamoDB Developer Guide](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/)
- [Boto3 DynamoDB Documentation](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/dynamodb.html)
- [DynamoDB Best Practices](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)

---

**[‚¨ÖÔ∏è Volver al README principal](../README.md)**

